# 62.不同路径

### LeetCode 题目链接

[62.不同路径](https://leetcode.cn/problems/unique-paths/)

### 解题

可以使用动态规划来解决这个问题

设定 `dp[i][j]` 为到达网格位置 `(i, j)` 的不同路径数。初始时，`dp[0][0] = 1`，表示起点只有一种路径

对于其他位置 `(i, j)`：
- 机器人只能从 `(i-1, j)` 或 `(i, j-1)` 位置到达 `(i, j)`
- 因此，状态转移方程为：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`
  
可以从左上角开始填充 `dp` 数组，最终 `dp[m-1][n-1]` 即为到达右下角的不同路径数

注意：因为 `dp[i][j]` 的状态只依赖于 `dp[i-1][j]` 和 `dp[i][j-1]`，而在进行遍历时的顺序刚好是从上至下、从左到右。所以可以使用长度为 `n` 的一维数组来保存状态，从而优化空间复杂度。在每次迭代中，仅用一个数组 `dp[j]` 来保存当前行的路径数，并不断更新它

```js
var uniquePaths = function(m, n) {
    // 初始化一维数组，长度为 n，所有元素初始化为 1
    const dp = new Array(n).fill(1);
    // 遍历每一行，从第二行开始
    for(let i = 1; i < m; i++) {
        // 从第二列开始更新 dp 数组
        for(let j = 1; j < n; j++) {
            // 更新当前 dp[j] 为 dp[j] + dp[j-1]
            dp[j] += dp[j - 1];
        }
    }
    return dp[n - 1];
};
```
```python
# 写法 1
def unique_paths(m: int, n: int) -> int:
    dp = [[1] * n for _ in range(m)]
    
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    
    return dp[-1][-1]

# 优化空间版
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 初始化一维数组，全部设置为 1，因为第一行和第一列的路径数都为 1
        # 由于在起始点 (0, 0) 处，机器人只能向下或向右移动
        # 因此，在网格的第一行和第一列，每个位置的路径数都只有 1 条（只能从左到右或从上到下直线到达），所以将所有值初始化为 1
        dp = [1] * n

        # 遍历每一行，从第二行开始
        # range(1, m) 生成从 1 到 m-1 的所有数字，即 i 的取值范围是从 1 到 m-1
        # 从第一行（i = 0）开始，所有路径数已被初始化为 1，无需修改。因此，遍历从第二行开始即可
        for i in range(1, m):
            # 从第二列开始更新 dp 数组
            # range(1, n) 生成从 1 到 n-1 的所有数字，即 j 的取值范围是从 1 到 n-1
            # 网格的第一列（j = 0）在初始化时所有值都是 1，表示只能从上往下直线移动到达这些位置，无需更新，因此从第二列开始更新路径数
            for j in range(1, n):
                # 更新当前 dp[j] 为 dp[j] + dp[j-1]
                # dp[j]：表示的是到达 (i, j) 位置时的路径数（该值包含了从上方位置 (i-1, j) 来的路径数）
                # dp[j - 1]：表示从左边 (i, j-1) 到当前位置 (i, j) 的路径数
                dp[j] += dp[j - 1]
        
        return dp[-1]
```
- 时间复杂度：`O(m * n)`，遍历整个 `m x n` 的网格
- 空间复杂度：`O(n)`，只使用一维数组来保存路径数